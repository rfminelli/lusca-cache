#summary Adrian's Code TODO List.

= Introduction =

A whole lot of cleanup work needs to be done to make the more difficult work less painful.

This page is meant primarily as a kick for Adrian to remember what he needs to do.

= Code Changes =

  * Begin shuffling stuff out of src/ that isn't strictly required to be there and is trivial to reorganise (makes code reuse and unit testing easier to sort out)
   * dlink list *done*
   * debug/ctx *done*
   * gb_t *done*
   * kb_t - *done*
   * mem *done*
    * Move initialisation of types init'ed in mem.c out into component modules *done*
    * Convert the legacy mem.c types into locally-scoped MemPool types, reducing the mem.c stuff to buffers only *done*
   * mempool *done*
   * memstr *done*
   * cbdata *done*
   * string *done*
   * membuf *done*

  * Next - error pages
    * write some simple sed one-liners to take a CSS + template file and generate a static error page *done*
    * Convert the English directory to use this - ignore the other languages for now! *done*

  * Next phase - improving the communication code
    * Bring over a very naive reference-counted buffer type
    * Bring over a very, very basic writev() and readv() wrapper - remember about SSL and the FD_READ/WRITE_METHOD() stuff!
    * Use the writev() wrapper for writing HTTP replies, avoiding the copying

  * Next - resolve issue #10 (Service time differences!) if it hasn't been resolved already.

= Additions for Cacheboy-1.0 =

  * Solaris Event Ports - shouldn't be difficult; can almost merge /dev/poll + kqueue support to get network-only IO ports implemented (and ignore trying to use AIO for now!) - *done*
  * Nothing else - get the codebase out there and stable! - *done*
  * Error pages, perhaps? - *done, for english*

= Additions for Cacheboy-1.1 =

  * Tidy up and commit the ZPH patch stuff? this is already included in Squid-2.HEAD. *done, from squid-2.HEAD*
  * TPROXY-4 support - already coded up, just need to test it before committing! Or bring over what ends up in Squid-2.HEAD ? *commited, not tested at all!*
  * A writev() style vector method, as a basis for eventually shuffling around the header reply path?
  * Code restructuring into external libraries:
    * event queue (src/event.c) *done*
    * comm / fd *done* / disk *done* - these are somewhat intermingled; bring them over as a group and then tease them apart
    * src/aufs/aiops - bring it outside of aufs in this phase; worry about eliminating copies and including writev() support at a later date

= Benchmarking =

  * Benchmark with / without mempools - try to establish which areas of the codebase are (ab)using malloc far too often
  * Try to figure out the 'best' buffer sizes for doing socket and disk IO

= Comm restructuring =

This is more difficult than I thought. fd, disk and event moved out fine (but needed to move as one big chunk thanks to how everything is packed into the struct _fde); comm seems to initiate DNS lookups!

commConnectStart() takes a host -and- a struct in_addr for some reason. Its only used in one place in forward.c, when the connection is using the original client destination after name resolution failed.

This may need to be broken up into two bits - the "do dns lookup and call commConnect() with an IP address" bit (which will live in src/ for now, with the rest of the DNS code) and a commConnect() which simply initiates a connection to a single remote ip:port. This all may be slightly too intrusive to do in this pass, and may need to wait for a bit..

= Removing all the inet_ntoa() calls, etc =

This is slightly more difficult than it should be. Unfortunately, the output of inet_ntoa() that is squizzled away in the fde is then used when assembling various hash table entries.

The hash table code assumes that keys are NUL terminated.

The first pass to tidying up this mess is to rework the hash code so it can take a length parameter. "0" should be "NUL-terminated", an explicit length should be said explicit length. This should be attempted so to not introduce a performance regression due to lots of strlen() type calls to calculate lengths where they're unknown.

The next pass is to find the places where hashes including text versions of IP addresses and port numbers are used, and instead convert -those- to binary data + length keys. i bet a more special-purpose data structure could be used in each case where a hash is used involving an IP address (client db, pconn db, etc) but this'll do for now.

Finally, once all the places where inet_ntoa() and fde.desc are used and begin using binary versions where appropriate. This should cut back on the number of inet_ntoa() calls which abuse stdio functions inappropriately (its implemented using snprintf()!) and reduce the CPU overhead a % or two.
