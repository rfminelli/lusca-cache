#summary Adrian's Code TODO List.

= Introduction =

A whole lot of cleanup work needs to be done to make the more difficult work less painful.

This page is meant primarily as a kick for Adrian to remember what he needs to do.

= Code Changes =

  * Begin shuffling stuff out of src/ that isn't strictly required to be there and is trivial to reorganise (makes code reuse and unit testing easier to sort out)
   * dlink list *done*
   * debug/ctx *done*
   * gb_t *done*
   * kb_t - *done*
   * mem *done*
    * Move initialisation of types init'ed in mem.c out into component modules *done*
    * Convert the legacy mem.c types into locally-scoped MemPool types, reducing the mem.c stuff to buffers only *done*
   * mempool *done*
   * memstr *done*
   * cbdata *done*
   * string *done*
   * membuf *done*

  * Next - error pages
    * write some simple sed one-liners to take a CSS + template file and generate a static error page *done*
    * Convert the English directory to use this - ignore the other languages for now! *done*

  * Next - whatever bits of the http code can easily be moved
    * HttpVersion *done*
    * HttpStatusLine *done*
    * Header / HeaderEntry
    * HttpRequest
    * HttpReply
    * Body related callback pipeline?
    * HdrCC stuff
    * Range request stuff
    * What else?


  * Next - bring out the event *done*, comm *done*, fd *done*, disk code *done*
  * Next - bring out the async io code
  * Next - improve communications code, cut #1
   * callback based recvfrom(); keep calling the handler for each recvfrom() called until deregistered
   * convert over recvfrom() users to use this - src/dns_internal.c ; src/htcp.c ; src/icmp.c ; src/icp_v2.c ; src/snmp_core.c ; src/wccp.c ; src/wccp2.c
   * what else? a comm_read() ? Remember the old argument of "provide buffer" versus "receive buffer"
  * Wrap up the initialisation and event run stuff in libiapp/ so the main loop can be used outside of squid's src/

  * Next phase - improving the communication code #2
    * Bring over a very naive reference-counted buffer type
    * Bring over a very, very basic writev() and readv() wrapper - remember about SSL and the FD_READ/WRITE_METHOD() stuff!
    * Use the writev() wrapper for writing HTTP replies, avoiding the copying

  * Next - resolve issue #10 (Service time differences!) if it hasn't been resolved already.

= Additions for Cacheboy-1.0 =

  * Solaris Event Ports - shouldn't be difficult; can almost merge /dev/poll + kqueue support to get network-only IO ports implemented (and ignore trying to use AIO for now!) - *done*
  * Nothing else - get the codebase out there and stable! - *done*
  * Error pages, perhaps? - *done, for english*

= Additions for Cacheboy-1.1 =

  * Tidy up and commit the ZPH patch stuff? this is already included in Squid-2.HEAD. *done, from squid-2.HEAD*
  * TPROXY-4 support - already coded up, just need to test it before committing! Or bring over what ends up in Squid-2.HEAD ? *commited, not tested at all!*
  * A writev() style vector method, as a basis for eventually shuffling around the header reply path?
  * Code restructuring into external libraries:
    * event queue (src/event.c) *done*
    * comm / fd *done* / disk *done* - these are somewhat intermingled; bring them over as a group and then tease them apart
    * src/aufs/aiops - bring it outside of aufs in this phase; worry about eliminating copies and including writev() support at a later date

= Benchmarking =

  * Benchmark with / without mempools - try to establish which areas of the codebase are (ab)using malloc far too often
  * Try to figure out the 'best' buffer sizes for doing socket and disk IO

= Comm restructuring =

This is more difficult than I thought. fd, disk and event moved out fine (but needed to move as one big chunk thanks to how everything is packed into the struct _fde); comm seems to initiate DNS lookups!

commConnectStart() takes a host -and- a struct in_addr for some reason. Its only used in one place in forward.c, when the connection is using the original client destination after name resolution failed.

This may need to be broken up into two bits - the "do dns lookup and call commConnect() with an IP address" bit (which will live in src/ for now, with the rest of the DNS code) and a commConnect() which simply initiates a connection to a single remote ip:port. This all may be slightly too intrusive to do in this pass, and may need to wait for a bit..

= Removing all the inet_ntoa() calls, etc =

This is slightly more difficult than it should be. Unfortunately, the output of inet_ntoa() that is squizzled away in the fde is then used when assembling various hash table entries.

The hash table code assumes that keys are NUL terminated.

The first pass to tidying up this mess is to rework the hash code so it can take a length parameter. "0" should be "NUL-terminated", an explicit length should be said explicit length. This should be attempted so to not introduce a performance regression due to lots of strlen() type calls to calculate lengths where they're unknown.

The next pass is to find the places where hashes including text versions of IP addresses and port numbers are used, and instead convert -those- to binary data + length keys. i bet a more special-purpose data structure could be used in each case where a hash is used involving an IP address (client db, pconn db, etc) but this'll do for now.

Finally, once all the places where inet_ntoa() and fde.desc are used and begin using binary versions where appropriate. This should cut back on the number of inet_ntoa() calls which abuse stdio functions inappropriately (its implemented using snprintf()!) and reduce the CPU overhead a % or two.

= Storage related stuff =

Eventually, once all of the data pipeline has been rescued and fixed, disk IO should be done in chunks greater than 4k. Finding the balance will take some time, but i bet 4k isn't it.

The swaplog writing is blocking, even for AUFS. Thats just plain stupid.

The rebuilding logic for COSS sucks because there's no per-stripe metadata being kept. That should really be revisited!

The rebuild logic for AUFS sucks because both the swaplog reading is blocking and the directory rebuilding is blocking. This should be taught to properly use the async IO routines.

It'd be nice if ufs and aufs were merged. It'd be doubly nice if ufs, aufs and diskd were merged -but- diskd's concept of disk IO is quite restrictive (there's an upper limit on the number of IOs that can be scheduled due to sysvshm and msgq limits.) Ideally, diskd IO would be scheduled through an AUFS-like intermediary queue so more IO can be queued versus dispatched, but .. save FreeBSD-4 and badly-setup Solaris machines, there's no need for diskd any more. Leave it as is, tidy up the disk code to provide blocking/aufs/POSIX AIO versions of the IO routines, then unify ufs/aufs.

POSIX AIO under FreeBSD *should* allow for copy-free data in and out for disk IO (re-read the code to make sure!) In any case, FreeBSD's POSIX AIO + kqueue notification is probably sensible enough to do the bulk of IO with. Its just a shame there's no AIO open/close operators - AUFS threads are still needed for that.